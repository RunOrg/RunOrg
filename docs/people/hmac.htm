<page title="Authenticate with HMAC proof"
      api="GET /db/{db}/people/auth/hmac" 
      tags="methods:person methods:auth"
      parent="people.htm" />
<doc for="api">
  Processes an HMAC proof generated by a trusted party using a shared secret key, and uses it
  to authenticate a person.

  The typical use case is when you already control an authentication server (such as your
  existing website), and need a way to have that server tell RunOrg that a given individual
  is authenticated. In this scenario, your authentication server plays the role of the
  trusted party and generates an HMAC proof which the client then sends to RunOrg using
  this endpoint.

  # Request

  The request body contains the following fields: 
</doc>
<fields for="api">
  id      | <id>   | The identifier of the person that the user is authenticating as. 
  expires | <time> | The time after which this token becomes invalid, formatted as an
                     [ISO-8601 timestamp](/concepts/time.htm). 
  key     | <id>   | The identifier of the secret key used to compute the HMAC, as
                     returned by the [create key endpoint](/keys/create.htm).
  proof   | <hex>  | The HMAC proof, encoded in hexadecimal.
</fields>
<doc for="api">

  The server generates the **assertion**, which is constructed as follows: 
 
  `auth:<id>:until:<expires>`

  For instance, if authenticating as user `0Et9j0026rO` until midnight on 
  the first of may 2014, the assertion would be: 
 
  `auth:0Et9j0026rO:until:2014-05-01T23:59:59Z`

  Once the assertion is generated, the HMAC is computed using the stored key,
  and compared with the hex proof. 

  # Response

  Always `200 OK`: this is an [idempotent](/concepts/idempotent.htm) endpoint.

  The response contains two fields: 
</doc>
<fields for="api">
  token | <token>  | An [authentication token](/auth/token.htm).
  self  | <person> | The [short profile](/people/person.htm) of the authenticated 
                     person.
</fields>
<doc for="api">
  
  Please consult the Errors section below for ways to debug this method.

  # Examples

</doc>
<example type="api" caption="Example request">
  POST /db/0Et4X0016om/people/auth/hmac
  Content-Type: application/json

  { "id": "0Et9j0026rO",
    "expires": "2014-05-01T23:59:59Z",
    "key": "0wt3s0566xO",
    "proof": "5063ae6d2f7f858ea24598d7036f4a27a468a2fd" }
</example>
<example type="api" caption="Example response">
   202 Accepted 
   Content-Type: application/json

   { "token": "7Rq03AsR92W",
     "self": { 
       "id" : "0Et9j0026rO",
       "label" : "Victor Nicollet",
       "gender" : "M", 
       "pic" : "https://www.gravatar.com/avatar/648e25e4372728b2d3e0c0b2b6e26f4e" } }
</example>
<doc for="api">
  # Errors

  ## Returns `400 Bad Request`
  - ... if `proof` was not correctly hex-encoded
  - ... if `expires` has already passed

  ## Returns `401 Forbidden` 
  - ... if the proof is invalid. 
 
  ## Returns `404 Not Found`
  - ... if database `{db}` does not exist
  - ... if key `{key}` does not exist in database `{db}`
  - ... if person `{id}` does not exist in database `{db}`
 
  Debugging a `401` status code when HMACs and secret keys are involved can be 
  very annoying ; the RunOrg API includes some helpful information to help you 
  find the root cause. 
</doc>
<example type="api" caption="Example 401 response">
  401 Forbidden
  Content-Type: application/json

  { "error" : "Invalid proof",
    "path"  : "/db/{db}/people/auth/hmac",
    "detail": {
      "assertion": "auth:0Et9j0026rO:until:2014-05-01T23:59:59Z",
      "debug": "d8ca358c10f5913f3e8f1b32a496116d6a6bfafb",
      "hash": "SHA-1" } }
</example>
<doc for="api">
  First, make sure that the assertion you use is the same as the `assertion` 
  returned by the API. 
  
  Then, make sure you are using the same `hash` (here, SHA-1) as the API.
  
  Then, try running your HMAC code with an empty key (a key with only
  zeros): if it does not match the `debug` field, then your HMAC code is wrong.
  
  Finally, if everything else works, it means the key you are using is 
  incorrect. Try generating a new one. 

  # Access restrictions
 
  None: anyone can attempt to authenticate. 
</doc>
