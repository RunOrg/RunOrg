# Presentation Language

A small DSL for creating server-side and client-side interfaces for RunOrg.

## Templates

PLang compiles HTML files (extensions `.html`, `.htm`) found in the
source directory, and turns them into rendering functions. That is, if
`R` is a renderer and file `/path/to/template.html` was present in the
source directory, then function `R.path.to.template()` will render the
contents of that template.

### Simple variables

A simple template file like:

    <h1>{{ title }}</h1>

Would be compiled into:

    function(data) {
      this.put('<h1>');
      this.escape(data.title)
      this.put('</h1>');
    }

Note that variables are **always escaped**. 

Member access is possible, for instance: 

    <h1>{{ page.title }}</h1>

Would be compiled into: 

    function(data) {
      this.put('<h1>');
      this.escape(data.page.title)
      this.put('</h1>');
    }

If you need to use `data` itself (and not one of its members), use
the variable `@`.

### Sub-rendering

Sometimes, instead of passing strings, we wish to pass rendering functions as
variables: 

    <div class="body">{( body )}</div>

This will be compiled to: 

    function(data) {
      this.put('<div class="body">');
      data.body.call(this);
      this.put('</div>');
    }

### Sub-templates

A sub-template is a function that renders non-escaped HTML, whether 
that is an actual template generated by PLang or a hand-written 
function. 

A template file like: 

    <div class=body>
      {< page.parts.body >}
    </div>

Will be compiled to: 

    function(data) {
      this.put('<div class=body>\n');
      this.page.parts.body(data);
      this.put('\n</div>');
    }

Note: the current data object is passed to the template. It is
possible to specify another argument instead: 

    <div class=body>
      {< page.parts.body body >}
    </div>

Will be compiled to: 

    function(data) {
      this.put('<div class=body>\n');
      this.page.parts.body(data.body);
      this.put('\n</div>');
    }

### Block sub-templates

A block sub-template is a sub-template that constructs its 
parameters based on how it is called, rather than just using 
the current data object.

    {< decoration.pretty user }
       <span>{{ name }}</span>
    {>}

Will be compiled to: 

    function(data) {
      this.decoration.pretty({
        data: data,
        args: [ data.user ],
        blocks: {
          'first': function() { 
            this.put('<span>');
            this.escape(data.name);
            this.put('</span>');
          }
        }
      });
    }

A block sub-template may include several named blocks, separated
by their names, for instance: 

    {< decoration.pretty user }
      <span>{{ name }}</span>
    {pic}
      <img src="{{ @ }}"/>
    {>}

Will be compiled to: 

    function(data) {
      this.decoration.pretty({
        data: data,
        args: [ data.user ],
        blocks: {
          'first': function() { 
            this.put('<span>');
            this.escape(data.name);
            this.put('</span>');
          },
          'pic': function() {
            this.put('<img src="');
	    this.escape(data);
	    this.put('"/>');
	  }
        }
      });
    }

Use sub-renderers to display the blocks, for instance: 

    <div class="user">
      <div class="pic">{( blocks.pic )}</div>
      <div class="name">{( blocks.first )}</div>
    </div>

#### 'If' sub-template

This sub-template is handled automatically by the compiler.

    {< if condition }
      A
    {else}
      B
    {>}

Will be compiled to the more proper: 
  
    function(data) {
      if (data.condition) { 
        this.put('A');
      } else {
        this.put('B');
      }
    }

The `else` clause is, of course, optional.

The condition should be a simple expression: 

    <cond>: <name>
          | ! <cond>
          | <cond> && <cond>
          | <cond> || <cond>
          | <expr> <op> <expr>
    
    <expr>: <name>
          | null
          | <int>

    <name>: <ident>
    	  | <name>.<ident>

    <op>: == 
        | === 
        | <
        | <= 
        | >
        | >=
        | !=
        | !== 

#### 'Each' sub-template

This sub-template is handled automatically by the compiler.

    {< if list.length }
      <ul>
      {< each list }
        <li><a href="mailto:{{ email }}">{{ name }}</a></li>
      {>}
      </ul>
    {>}

Compiles to: 

    function(data) {   
      if (data.list.length) {
        this.put('<ul>');
        for (var i = 0; i < data.list.length; ++i) {
          (function(data){
	    this.put('<li><a href="mailto:');
	    this.escape(data.email);
	    this.put('">');
	    this.escape(data.name);
	    this.put('</a></li>');
	  }).call(this,data.list[i]);
        }
	this.put('</ul>');
      }
    }

### Callbacks 

It is possible to call user-provided functions on pieces of the DOM once they
have been created. For example: 

    <ul {$ fill $}></ul>

This will create the `<ul></ul>` element, then call function `data.fill` on a brand
new renderer that draws to that element. For example: 

   { fill: function(R) {
     API.GET("/items",{},function(response) {
       R.listItems(response.items).show();
     })
   } }

### Internationalization

Internalization files are named `[lang].i18n.js`. They follow a simple
`key: binding` syntax similar to JSON:

    i18n({
	"page.edit.title": "Titre de la page",
        "page.edit.submit": "Enregistrer",
        "page.all.count": function(n) { return n == 1 ? "1 page" : n + " pages"; }
    });

The file *should* use double quotes instead of single quotes.

They are invoked from templates using the following syntax: 

    <h2>{: page.all.count pages.length :}</h2>

Which is automatically turned into: 

    function(data) {   
      this.put('<h2>');
      this.escape(
        (function(n){ return n == 1 ? '1 page' : n + ' pages'; })
	(data.pages.length));
      this.put('</h2>'); 
    }    

There is one different JS file output for every language, and the contents are
inlined.	

