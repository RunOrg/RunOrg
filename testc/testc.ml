(** The test compiler. Recursively reads the contents of directory "test", and parses
    the files found inside. 

    Each {b javascript} file should contain a header as follows: 

    {[
// GET /db/{db}/contacts/{id}
// Contacts / Fetch basic information for contact {id}
    ]}

    This header will be cut as such: 

    {[
// [VERB] [PATH]
// [CATEGORY] / [DESCRIPTION]
    ]}

    These elements will then be made part of a JSON structure bound to the element: 

    {[
{ verb: "GET", 
  path: "/db/{db}/contacts/{id}",
  file: "wherever/the/file/was.js", 
  categories: [ "Contacts" ],
  description: "Fetch basic information for contact {id}",
  tests: 10 }
    ]}

    The 'tests' property is populated by counting the number of calls to the [TEST()] 
    javascript function. 

    Each {b markdown} file should contain a header as follows: 

    {[
Contacts / Short contact information 
    }]

    This header is cut as such: 

    {[
[CATEGORY] / [DESCRIPTION]
    ]}

    These elements are inserted into a JSON structure bound to the element: 

    {[
{ file: "wherever/the/file/was.md", 
  categories: [ "Contacts" ],
  description: "Short contact information" }
    ]}
*)

type js = {
  verb : string ;
  path : string ;
  tests : int 
}

type meta = {
  file : string ; 
  categories : string list ;
  description : string ;
  js : js option ; 
}

(* Generating the output file 
   ========================== *)

let to_string meta = 
  Printf.sprintf 
    "Json.Object [  
    \"file\", Json.String %S ;
    \"categories\", Json.Array [%s] ; 
    \"description\", Json.String %S ;%s
  ]"
    meta.file
    (String.concat " ; " (List.map (Printf.sprintf "Json.String %S") meta.categories))
    meta.description 
    (match meta.js with None -> "" | Some js -> Printf.sprintf "    
    \"tests\", Json.Int %d ;
    \"path\", Json.String %S ;
    \"verb\", Json.String %S ;"
      js.tests js.path js.verb)

let all_to_string metas = 
  "(* This file was generated by testc. *)"
  ^ "\nlet all = [" 
  ^ String.concat " ; " (List.map (fun meta -> 
    Printf.sprintf "\n  %S, %s" meta.file (to_string meta)) metas) ^ "]"

let output metas =
  let contents = all_to_string metas in 
  let path = "server/test.ml" in
  let chan = open_out path in 
  output_string chan contents ;
  close_out chan ;
  Printf.printf "%s: %d bytes\n%!" path (String.length contents) 

(* Parsing an individual file 
   ========================== *)

let has_extension ext filename = 
  let len = String.length filename in 
  let extlen = String.length ext in 
  extlen < len &&
    String.lowercase (String.sub filename (len - extlen) extlen) = ext

let is_js = has_extension ".js"
let is_md = has_extension ".md"

let parse_line1 = 
  let re = Str.regexp "^//[ \t]*\\([A-Z]+\\)[ \t]+\\([^\n\r]+\\)" in
  fun line ->
    if Str.string_match re line 0 then 
      let verb = Str.matched_group 1 line in
      let path = Str.matched_group 2 line in 
      (verb, path) 
    else
      failwith "Could not parse first line."

let parse_line2 = 
  (* This does not require an initial //, so it works on both MD and JS files. *)
  let re = Str.regexp "[ \t]*/[ \t]*" in
  fun line ->
    let splits = List.filter (fun s -> s <> "") (Str.split re line) in
    match List.rev splits with 
    | [] -> assert false
    | desc :: categories -> (desc, List.rev categories)

let test_re = Str.regexp "TEST("

let rec count_tests acc chan = 
  let line = try Some (input_line chan) with _ -> None in
  match line with None -> acc | Some line -> 
    count_tests (if Str.string_match test_re line 0 then acc + 1 else acc) chan

let readjs file = 
  let path = "test/" ^ file in 
  Printf.printf "Parsing %s\n" path ; 
  let chan = open_in path in 
  let verb, path = parse_line1 (input_line chan) in 
  let description, categories = parse_line2 (input_line chan) in
  let tests = count_tests 0 chan in 
  close_in chan ;
  { js = Some { tests ; verb ; path } ; file ; description ; categories }

let readmd file = 
  let path = "test/" ^ file in 
  Printf.printf "Parsing %s\n" path ; 
  let chan = open_in path in 
  let description, categories = parse_line2 (input_line chan) in
  close_in chan ;
  { js = None ; description ; categories ; file }

let read file = 
  if is_js file then readjs file else readmd file

(* Seeking and parsing all files 
   ============================= *)

let read_dir path = 
  try Array.to_list (Sys.readdir (Filename.concat "test" path))  
  with exn -> 
    print_endline 
      (Printf.sprintf "While reading directory %S:\n%s" path 
	 (Printexc.to_string exn)) ;
    exit (-1)

let is_directory path = 
  try Sys.is_directory (Filename.concat "test" path) 
  with exn -> 
    print_endline 
      (Printf.sprintf "While testing if %S is a directory:\n%s" path 
	 (Printexc.to_string exn)) ;
    exit (-1)
    
let get_all_files path = 
  
  let rec fold path acc =     
    List.fold_left (fun acc name ->
      let path = if path = "" then name else Filename.concat path name in 
      if is_directory path then
	fold path acc
      else if is_js name || is_md name then
	path :: acc 
      else 
	acc
    ) acc (read_dir path) 
  in
  
  fold path []

let parse_all_files path = 
  let files = get_all_files path in
  let parsed =  List.map read files in
  let path m = match m.js with None -> ">" | Some js -> js.path in
  List.sort (fun a b -> compare (path a) (path b)) parsed

(* Read, then write
   ================ *)

let () = 
  output (parse_all_files "") 
