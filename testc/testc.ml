(** The test compiler. Recursively reads the contents of directory "test", and parses
    the files found inside. 

    Each {b javascript} file should contain a header as follows: 

    {[
// GET /db/{db}/contacts/{id}
    ]}

    These elements will then be made part of a JSON structure bound to the element: 

    {[
{ verb: "GET", 
  path: "/db/{db}/contacts/{id}",
  file: "wherever/the/file/was.js", 
  tests: 10 }
    ]}

    The 'tests' property is populated by counting the number of calls to the [TEST()] 
    javascript function. 
*)

type js = {
  verb : string ;
  path : string ;
  file : string ; 
  tests : int 
}

(* Generating the output file 
   ========================== *)

let to_string js = 
  Printf.sprintf 
    "Json.Object [  
    \"file\", Json.String %S ;
    \"tests\", Json.Int %d ;
    \"path\", Json.String %S ;
    \"verb\", Json.String %S ;
  ]"
    js.file js.tests js.path js.verb

let all_to_string metas = 
  "(* This file was generated by testc. *)"
  ^ "\nlet all = [" 
  ^ String.concat " ; " (List.map (fun meta -> 
    Printf.sprintf "\n  %S, %s" meta.file (to_string meta)) metas) ^ "]"

let output metas =
  let contents = all_to_string metas in 
  let path = "server/test.ml" in
  let chan = open_out path in 
  output_string chan contents ;
  close_out chan ;
  Printf.printf "%s: %d bytes\n%!" path (String.length contents) 

(* Parsing an individual file 
   ========================== *)

let has_extension ext filename = 
  let len = String.length filename in 
  let extlen = String.length ext in 
  extlen < len &&
    String.lowercase (String.sub filename (len - extlen) extlen) = ext

let is_js = has_extension ".js"

let parse_line1 = 
  let re = Str.regexp "^//[ \t]*\\([A-Z]+\\)[ \t]+\\([^\n\r]+\\)" in
  fun line ->
    if Str.string_match re line 0 then 
      let verb = Str.matched_group 1 line in
      let path = Str.matched_group 2 line in 
      (verb, path) 
    else
      failwith "Could not parse first line."

let test_re = Str.regexp "TEST("

let rec count_tests acc chan = 
  let line = try Some (input_line chan) with _ -> None in
  match line with None -> acc | Some line -> 
    count_tests (if Str.string_match test_re line 0 then acc + 1 else acc) chan

let readjs file = 
  let path = "test/" ^ file in 
  Printf.printf "Parsing %s\n" path ; 
  let chan = open_in path in 
  let verb, path = parse_line1 (input_line chan) in 
  let tests = count_tests 0 chan in 
  close_in chan ;
  { tests ; verb ; path ; file }

(* Seeking and parsing all files 
   ============================= *)

let read_dir path = 
  try Array.to_list (Sys.readdir (Filename.concat "test" path))  
  with exn -> 
    print_endline 
      (Printf.sprintf "While reading directory %S:\n%s" path 
	 (Printexc.to_string exn)) ;
    exit (-1)

let is_directory path = 
  try Sys.is_directory (Filename.concat "test" path) 
  with exn -> 
    print_endline 
      (Printf.sprintf "While testing if %S is a directory:\n%s" path 
	 (Printexc.to_string exn)) ;
    exit (-1)
    
let get_all_files path = 
  
  let rec fold path acc =     
    List.fold_left (fun acc name ->
      let path = if path = "" then name else Filename.concat path name in 
      if is_directory path then
	fold path acc
      else if is_js name then
	path :: acc 
      else 
	acc
    ) acc (read_dir path) 
  in
  
  fold path []

let parse_all_files path = 
  let files = get_all_files path in
  let parsed =  List.map readjs files in
  let printed = List.filter (fun f -> f.tests > 0) parsed in 
  List.sort (fun a b -> compare a.path b.path) printed

(* Read, then write
   ================ *)

let () = 
  output (parse_all_files "") 
