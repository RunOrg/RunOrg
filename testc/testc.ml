(** The test compiler. Recursively reads the contents of directory "test", and parses
    the files found inside. Each file should contain a header as follows: 

    {[
// GET /db/{db}/contacts/{id}
// Contacts / Fetch basic information for contact {id}
    ]}

    This header will be cut as such: 

    {[
// [VERB] [PATH]
// [CATEGORY] / [DESCRIPTION]
    ]}

    These elements will then be made part of a JSON structure bound to the element: 

    {[
{ verb: "GET", 
  path: "/db/{db}/contacts/{id}",
  file: "wherever/the/file/was.js", 
  categories: [ "Contacts" ],
  description: "Fetch basic information for contact {id}",
  tests: 10 }
    ]}

    The 'tests' property is populated by counting the number of calls to the [TEST()] 
    javascript function. 
*)

type meta = {
  file : string ; 
  verb : string ;
  path : string ;
  categories : string list ;
  description : string ;
  tests : int ;
}

(* Generating the output file 
   ========================== *)

let to_string meta = 
  Printf.sprintf 
    "Json.Object [ 
       \"verb\", Json.String %S ; 
       \"path\", Json.String %S ;
       \"file\", Json.String %S ; 
       \"categories\", Json.Array [%s] ; 
       \"description\", Json.String %S ;
       \"tests\", Json.Int %d ;
     ]"
    meta.verb meta.path meta.file
    (String.concat " ; " (List.map (Printf.sprintf "Json.String %S") meta.categories))
    meta.description meta.tests

let all_to_string metas = 
  "(* This file was generated by testc. *)"
  ^ "let all = [" 
  ^ String.concat " ; " (List.map (fun meta -> 
    Printf.sprintf "%S, %s" meta.file (to_string meta)) metas) ^ "]"

let output metas =
  let contents = all_to_string metas in 
  let path = "server/test.ml" in
  let chan = open_out path in 
  output_string chan contents ;
  close_out chan ;
  Printf.printf "%s: %d bytes\n%!" path (String.length contents) 

(* Parsing an individual file 
   ========================== *)

let parse_line1 = 
  let re = Str.regexp "^//[ \t]*\\([A-Z]+\\)[ \t]+\\([^\n\r]+\\)" in
  fun line ->
    if Str.string_match re line 0 then 
      let verb = Str.matched_group 1 line in
      let path = Str.matched_group 2 line in 
      (verb, path) 
    else
      failwith "Could not parse first line."

let parse_line2 = 
  let re = Str.regexp "[ \t]*/[ \t]*" in
  fun line ->
    let splits = List.filter (fun s -> s <> "") (Str.split re line) in
    match List.rev splits with 
    | [] -> assert false
    | desc :: categories -> (desc, List.rev categories)

let test_re = Str.regexp "TEST("

let rec count_tests acc chan = 
  let line = try Some (input_line chan) with _ -> None in
  match line with None -> acc | Some line -> 
    count_tests (if Str.string_match test_re line 0 then acc + 1 else acc) chan

let read file = 
  let path = "test/" ^ file in 
  Printf.printf "Parsing %s\n" path ; 
  let chan = open_in path in 
  let verb, path = parse_line1 (input_line chan) in 
  let description, categories = parse_line2 (input_line chan) in
  let tests = count_tests 0 chan in 
  close_in chan ;
  { file ; verb ; path ; description ; categories ; tests }

(* Seeking and parsing all files 
   ============================= *)

let read_dir path = 
  try Array.to_list (Sys.readdir (Filename.concat "test" path))  
  with exn -> 
    print_endline 
      (Printf.sprintf "While reading directory %S:\n%s" path 
	 (Printexc.to_string exn)) ;
    exit (-1)

let is_directory path = 
  try Sys.is_directory (Filename.concat "test" path) 
  with exn -> 
    print_endline 
      (Printf.sprintf "While testing if %S is a directory:\n%s" path 
	 (Printexc.to_string exn)) ;
    exit (-1)

let has_extension filename = 
  let ext = ".js" in
  let len = String.length filename in 
  let extlen = String.length ext in 
  extlen < len &&
    String.lowercase (String.sub filename (len - extlen) extlen) = ext
    
let get_all_files path = 
  
  let rec fold path acc =     
    List.fold_left (fun acc name ->
      let path = if path = "" then name else Filename.concat path name in 
      if is_directory path then
	fold path acc
      else if has_extension name then
	path :: acc 
      else 
	acc
    ) acc (read_dir path) 
  in
  
  fold path []

let parse_all_files path = 
  let files = get_all_files path in
  List.map read files

(* Read, then write
   ================ *)

let () = 
  output (parse_all_files "") 
