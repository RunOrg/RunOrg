# Template DSL documentation

This document is a detailed overview of what the template DLS aims to
become, and may not be representative of what has actually been
implemented.

RunOrg uses a DSL for its template system, rather than leverage an
existing language or engine, for several reasons:

 - **Generator-friendliness**: templates are expected to be generated by client code, 
   rather than written by hand. The language uses a simplified, streamlined, non-ambiguous 
   syntax to keep generator code as lean as possible. 

 - **Domain-specific features**: most operations required when generating a document
   based on a template are supported first-class features of the language, such as flat
   lists or implicit HTML escaping. 

 - **Static analysis**: templates run as part of the RunOrg process and need proper
   sandboxing. The structure of the language guarantees bounds on execution time, 
   memory usage, and the absence of runtime errors.

## Execution model

The DSL is an expression-based, lazy, pure functional language. A
program is a single expression, building the expected result which is
usually a list of strings to be concatenated by the RunOrg and
displayed. That program has access to several underlying data stores,
depending on the situation: **inline** data (which was provided along
with the program when the template was created), **context** data (the
template is intended to format that data correctly) and **API** data
(provided on request, assuming proper credentials are provided). All
data is provided in JSON format, and the result of the program is also
converted to JSON.

## Data types and literals

Parametric data types (such as lists, maps, sets and flat lists) must 
be homogenous. It is not possible to have both integers and strings in 
a list. It is, however, legal to have a flat list of integers inside
another flat list of integers, because of the way flat lists work. 

 - **Primitives**: numbers, strings, booleans and `null` are provided
   in their JSON format. Only `"` quotes are supported for strings. 

 - **Lists**: behave like standard JSON arrays and are specified with
   the traditional JSON syntax: `[ a, b, c ]`.

 - **Maps**: map strings to values. Unlike javascript, using these to 
   represent objects is discouraged. In literals, both keys and values
   can be expressions: `{ a -> b, c -> d }`, though keys must evaluate
   to primitives or dates. 

 - **Sets**: keep unique copies of strings. Literals follow the same 
   syntax as maps, but without colons or arrows: `{ a, b, c }`.

 - **Records**: map field names to values. They do not support indexing
   (only accessing fields by hard-coded name) and do not behave as maps.
   They are described using standard JSON syntax: `{ a: b, c: d }`.

 - **Unbounded arrays, sets and records**: like their bounded
   counterparts, but there is no known limit to their size. Never
   appear as literals (or their size would be known). Collections in
   context and API data are usually unbounded.

 - **Flat lists**: behave like arrays, but a tree of flat lists nested
   inside other flat lists is turned into a _flat_ flat list. That is,
   `a ; ( b ; c )` is turned into `a ; b ; c`. 

 - **Lambdas**: anonymous functions that support currying. Implemented 
   with a lightweight syntax: `(a1 a2 a3 : expr)`.

 - **Escaped HTML**: an HTML value that should not be escaped again. 
   Not a literal, but may be obtained by applying the `html()` built-in
   function to a string. 

 - **Time**: a dedicated representation of a date and time. May be 
   obtained by applying the `date()` built-in function to a string, or
   with the `'yyyy-mm-dd` and `'yyyy-mm-ddThh:ii:ssZ` literals. 

 - **TimeSpan**: a dedicated representation of a duration. Different
   from just a number, because `date + months(1)` has a meaning that
   cannot be expressed in terms of `date + days(X)`.    

There are no tuples, so `f(a)(b) is equivalent to `f(a,b)` and
`f(,b)` is equivalent to `(x: f(x,b))`. 

## Standard library

### Iteration

Bounded collections support `set`, `map`, `list` and `each` functions, 
which return sets, maps, lists and flat lists respectively. These functions
perform filtering, mapping and concatenation: 

    { "a" -> "b", "d" -> "a" }.set(k v: {k , v}) == { "a", "b", "d" }

    [ "a", "a", "b" ].map(x: { x -> x }) == { "a" -> "a", "b" -> "b" }

    { "a" -> "b", "d" -> "a" }.each(k v: k ; v) == "a" ; "b" ; "d" ; "a"

    { "a" -> true, "b" -> false }.list(k v: v ? [k] : []) == ["a"] 

Bounded collections support `fold`, `find` and `filter`, as well as their 
extensions `min`, `max`, `any`, `all` and `contains`. 

Bounded collections, except flat lists, also support `count` (returns the 
number of elements). 

Unbounded collections do not support these at all. However, they may be 
turned into bounded collections by applying a limiter function: 

 - `collection.first(n)` and `collection.last(n)` gather the first or
   last `n` elements respectively. The concept of first and last on
   maps and sets is based on the case-sensitive ordering of their
   keys.

 - `collection.subset(n)` grab an arbitrary subset of size `n`
   elements in the collection. How the subset is chosen is
   unspecified.

All collections support `isEmpty`. 

### Member access

 - For maps: `expr[expr]` returns the value bound to the expression or
   `null` if missing.

 - For sets: `expr[expr]` returns `true` or `false` depending on
   whether the element appears in the set.

 - For lists, `expr[expr]` returns the value at that position, or
   [null] if missing. 

 - There is no member access on flat lists.

 - Object fields: `expr.field`. 

### Conditionals

 - `==` and `!=` are type-safe (the same type must be present on both
   sides, or cause a compiler error).

 - `a ?? b` returns `b` if `a` is null, and `a` otherwise. Can be 
   chained. 

 - `a ? b : c` returns `b` if `a` is true, and `c` otherwise. 

 