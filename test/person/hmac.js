// POST /db/{db}/people/auth/hmac
// People / Authenticate with HMAC proof
// 
// Beta @ 0.0.0
//
// `200 OK`, [Idempotent](/docs/#/concept/idempotent.md).
//
// Processes an HMAC proof generated by a trusted party using a shared secret key, and uses it
// to authenticate a person.
//
// ### Request format
//     { "id"     : <person-id>,
//       "expires": <time>,
//       "key"    : <key-id>,
//       "proof"  : <hex-string> }
// - `id` is the identifier of the person that the user is authenticating as. 
// - `expires` is the time after which this token becomes invalid, formated as 
//   an [ISO-8601 timestamp](/docs/#/types/time.js).
// - `key` is the identifier of the secret key used to compute the HMAC, as
//   returned by the [create key endpoint](/docs/#/key/create.js).
// - `proof` is the HMAC proof, encoded in hexadecimal. 
//
// The server generates the **assertion**, which is constructed as follows: 
// 
//     auth:<id>:until:<expires>
// 
// For instance, if authenticating as user `0Et9j0026rO` until midnight on 
// the first of may 2014, the assertion would be: 
// 
//     auth:0Et9j0026rO:until:2014-05-01T23:59:59Z
//
// Once the assertion is generated, the HMAC is computed using the stored key,
// and compared with the hex proof. On success, a token and the user's profile
// are returned.
//
// ### Response format
//     { "token": <token>,
//       "self" : <shortperson> }
// - `token` is an [authentication token](/docs/#/types/token.js). 
// - `self ` is the [short profile](/docs/#/person/short-person.js) for the authenticated
//   person.
// 
// Please consult the Errors section below for ways to debug this method.
// 
// ### Example request
//     POST /db/0Et4X0016om/people/auth/hmac
//     Content-Type: application/json
//
//     { "id": "0Et9j0026rO",
//       "expires": "2014-05-01T23:59:59Z",
//       "key": "0wt3s0566xO",
//       "proof": "5063ae6d2f7f858ea24598d7036f4a27a468a2fd" }
// 
// ### Example response
//     200 OK
//     Content-Type: application/json
//
//     { "token": "7Rq03AsR92W",
//       "self": { 
//         "id" : "0Et9j0026rO",
//         "name" : "Victor Nicollet",
//         "gender" : "M", 
//         "pic" : "https://www.gravatar.com/avatar/648e25e4372728b2d3e0c0b2b6e26f4e" } }

TEST("Correctly authenticates user.", function(Query) {

    var example = { "email" : "vnicollet@runorg.com",
		    "name" : "Victor Nicollet",
		    "gender" : "M" };

    var db = Query.mkdb();
    var auth = Query.auth(db);
    var id = Query.post(["db/",db,"/people/import"],[example],auth)
	.then(function(d,s,r) { return d.imported[0]; });

    var key = "74e6f7298a9c2d168935f58c001bad88";
    var kid = Query.post(["db/",db,"/keys"],{"hash":"SHA-1","key":key,"encoding":"hex"},auth).id();

    return id.then(function(id) {
	
	var date = "2020-12-31T23:59:59Z";
        var assertion = "auth:" + id + ":until:" + date;
	    
	var sha1 = new jsSHA(assertion,"TEXT");
        var hmac = sha1.getHMAC(key,"HEX","SHA-1","HEX");
	
	var r = Query.post(["db/",db,"/people/auth/hmac"],{"id":id,"expires":date,"proof":hmac,"key":kid})
	    .then(function(d,s,r) { return d.self; });

	var expected = { 
	    "id": id, 
	    "label": "Victor Nicollet",
	    "gender": "M", 
	    "pic" : "https://www.gravatar.com/avatar/5a31b00f649489a9a24d3dc3e8b28060?d=identicon" 
	};
	
	return Assert.areEqual(expected, r);

    });

});

// # Errors 
//
// ## Returns `400 Bad Request`
// - ... if `proof` was not correctly hex-encoded
// - ... if `expires` has already passed
//
// ## Returns `401 Forbidden` 
// - ... if the proof is invalid. 
// 
// ## Returns `404 Not Found`
// - ... if database `{db}` does not exist

TEST("Returns 404 when database does not exist.", function(Query) {
    var hmac = {"id":"","expires":"1970-01-01","key":"","proof":""};
    return Query.post("/db/00000000001/people/auth/hmac", hmac)
	.assertStatus(404);
});

// - ... if key `{key}` does not exist in database `{db}`
// - ... if person `{id}` does not exist in database `{db}`

// Debugging a `401` status code when HMACs and secret keys are involved can be 
// very annoying ; the RunOrg API includes some helpful information to help you 
// find the root cause. 
// 
// ### Example 401 response
//     401 Forbidden
//     Content-Type: application/json
//     { "error" : "Invalid proof",
//       "path"  : "/db/{db}/people/auth/hmac",
//       "detail": {
//         "assertion": "auth:0Et9j0026rO:until:2014-05-01T23:59:59Z",
//         "debug": "d8ca358c10f5913f3e8f1b32a496116d6a6bfafb",
//         "hash": "SHA-1" } }
//
// First, make sure that the assertion you use is the same as the `assertion` 
// returned by the API. 
//
// Then, make sure you are using the same `hash` (here, SHA-1) as the API.
//
// Then, try running your HMAC code with an empty key (a key with only
// zeros): if it does not match the `debug` field, then your HMAC code is wrong.
//
// Finally, if everything else works, it means the key you are using is 
// incorrect. Try generating a new one. 
